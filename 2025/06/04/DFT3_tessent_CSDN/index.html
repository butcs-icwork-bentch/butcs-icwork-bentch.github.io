<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>DFT_tessent_csdn | Welcome to butcs-icworkbentch</title><meta name="author" content="butc"><meta name="copyright" content="butc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="提前声明：本文是csdn链接网页，非本人创建ATPG Basic Tool Flow 完成图8-1所示测试pattern生成所需的任务描述如下： 1.使用”Tessent-Shell”命令调用Tessent Shell。使用Set_context命令将context设置为”patterns-scan”，这允许访问ATPG功能。 2.ATPG工具需要一个结构（门级）设计网表和一个DFT库，您可以分别">
<meta property="og:type" content="article">
<meta property="og:title" content="DFT_tessent_csdn">
<meta property="og:url" content="https://butcs-icwork-bentch.github.io/2025/06/04/DFT3_tessent_CSDN/index.html">
<meta property="og:site_name" content="Welcome to butcs-icworkbentch">
<meta property="og:description" content="提前声明：本文是csdn链接网页，非本人创建ATPG Basic Tool Flow 完成图8-1所示测试pattern生成所需的任务描述如下： 1.使用”Tessent-Shell”命令调用Tessent Shell。使用Set_context命令将context设置为”patterns-scan”，这允许访问ATPG功能。 2.ATPG工具需要一个结构（门级）设计网表和一个DFT库，您可以分别">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/butcs-icwork-bentch/blogimg@main/imgOIP-C.png">
<meta property="article:published_time" content="2025-06-04T04:45:00.000Z">
<meta property="article:modified_time" content="2025-06-05T06:37:20.653Z">
<meta property="article:author" content="butc">
<meta property="article:tag" content="tessent">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/butcs-icwork-bentch/blogimg@main/imgOIP-C.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "DFT_tessent_csdn",
  "url": "https://butcs-icwork-bentch.github.io/2025/06/04/DFT3_tessent_CSDN/",
  "image": "https://cdn.jsdelivr.net/gh/butcs-icwork-bentch/blogimg@main/imgOIP-C.png",
  "datePublished": "2025-06-04T04:45:00.000Z",
  "dateModified": "2025-06-05T06:37:20.653Z",
  "author": [
    {
      "@type": "Person",
      "name": "butc",
      "url": "https://butcs-icwork-bentch.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://butcs-icwork-bentch.github.io/2025/06/04/DFT3_tessent_CSDN/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.3.5"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'DFT_tessent_csdn',
  isHighlightShrink: true,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: transparent;"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/butcs-icwork-bentch/blogimg@main/imgshaqiu.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Welcome to butcs-icworkbentch</span></a><a class="nav-page-title" href="/"><span class="site-name">DFT_tessent_csdn</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">DFT_tessent_csdn</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-04T04:45:00.000Z" title="发表于 2025-06-04 12:45:00">2025-06-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-05T06:37:20.653Z" title="更新于 2025-06-05 14:37:20">2025-06-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/DFT%E7%94%B5%E8%B7%AF/">DFT电路</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="提前声明：本文是csdn链接网页，非本人创建"><a href="#提前声明：本文是csdn链接网页，非本人创建" class="headerlink" title="提前声明：本文是csdn链接网页，非本人创建"></a><font color="red">提前声明：本文是csdn链接网页，非本人创建</font></h1><p>ATPG Basic Tool Flow</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/butcs-icwork-bentch/blogimg@main/img20250605143301382.png"><br>完成图8-1所示测试pattern生成所需的任务描述如下：</p>
<p>1.使用”Tessent-Shell”命令调用Tessent Shell。使用Set_context命令将context设置为”patterns-scan”，这允许访问ATPG功能。</p>
<p>2.ATPG工具需要一个结构（门级）设计网表和一个DFT库，您可以分别使用read_cell_library和read_verilog命令来完成。</p>
<p>3.读取库和网表后，工具进入设置模式。在设置模式中，可以交互地使用命令或通过使用dofile来执行多个任务。可以设置有关设计和设计扫描电路的信息。 </p>
<p>4.执行所有所需设置后，您可以退出设置模式，该模式会触发许多操作。如果这是第一次尝试退出设置模式，该工具将创建一个flatten的设计模型。 </p>
<p>5.接下来，该工具对该模型进行广泛的学习分析。 </p>
<p>6.一旦工具创建了一个flatten模型并学习了其行为，它就开始drc。 </p>
<p>7.一旦设计通过规则检查，该工具将进入分析模式，在该模式下，您可以对设计的模式集执行模拟。 </p>
<p>8.此时，您可能需要创建模式。您还可以执行一些其他设置步骤，例如添加故障列表。 在ATPG运行期间，该工具还执行故障模拟，以验证生成的模式检测目标故障。在任何一种情况下（完全或部分扫描），您都可以在不同的约束下运行ATPG，或者使用附加的测试模式来扩展测试向量集，以实现更高的测试覆盖率。</p>
<p>ATPG Tool Inputs and Outputs</p>
<p>ATPG工具使用多个输入来生成测试模式、故障列表和ATPG信息文件。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/butcs-icwork-bentch/blogimg@main/img20250605143356126.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/butcs-icwork-bentch/blogimg@main/img20250605143413494.png"><br>Basic ATPG Process</p>
<p>ATPG工具设置了默认值，因此当第一次启动ATPG时（通过发出create_patterns命令），该工具将对目标故障列表执行随机模式故障模拟和确定性测试生成的有效组合。</p>
<p>Random Pattern Generation Using the ATPG Tool</p>
<p>该工具首先对每个捕获时钟执行随机模式故障模拟，当模拟模式未能检测到至少0.5%的剩余故障时停止。然后，该工具对没有捕获时钟的模式以及测量连接到时钟线的主要输出的模式执行随机模式故障模拟。</p>
<p>Deterministic Test Generation Using the ATPG Tool</p>
<p>使用随机模式方法检测某些故障的可能性非常低。因此，在完成随机模式模拟之后，该工具对当前故障列表中的选定故障执行确定性测试生成。这个过程包括为故障列表中随机选择的一组故障创建测试模式。 在此过程中，工具将识别并从故障列表中删除冗余故障。在为故障模拟过程创建足够的模式后，它会显示一条消息，指示冗余故障的数量、ATPG不可测试故障的数量以及测试生成器识别的中止故障的数量。然后，该工具再次调用故障模拟器，从故障列表中删除所有检测到的故障，并将有效模式放入测试集中。然后，该工具选择另一组模式并重复该过程，直到当前故障列表中没有故障，测试生成期间中止的故障（即UC或UO类别中的故障）除外。  </p>
<p>ATPG Tool Timing Model</p>
<p>该工具使用基于周期的计时模型，将测试模式事件分组为测试周期。ATPG工具模拟器使用非扫描事件：force_pi、measure_po、capture_clock_on、capture_clock_off、ram_clock_ on和ram_clock _off。该工具使用固定的测试循环类型 用于ATPG；也就是说， 不能修改它。 最常用的测试周期包含事件：force_pi、measure_po、capture_clock_on和capture\uclock_off。用于读取或写入ram的测试向量包含事件force_pi、ram_clock_on和ram_clock _off，可以通过计时文件将每个事件实时关联起来。</p>
<p>ATPG Tool Pattern Types</p>
<p>ATPG工具有几种不同类型的测试模式。也就是说，它可以根据设计的样式和电路以及您指定的信息生成几种不同类型的pattern。默认情况下，该工具生成基本扫描模式，该模式采用全扫描设计方法。以下小节描述了基本的扫描模式，以及该工具可以生成的其他类型的模式。</p>
<p>Basic Scan Patterns</p>
<p>如上所述，该工具默认生成基本扫描模式。扫描模式包含将一组值强制到所有扫描单元和主要输入（force_pi）的事件，然后观察所有主要输出和扫描单元（measure_po）的结果响应。</p>
<p>该工具使用任何定义的扫描时钟将数据捕获到可观察的扫描单元中（capture_clock_on、capture_clock_off）。扫描模式参考适当的测试程序来定义如何控制和观察扫描单元。该工具要求每个扫描模式独立于所有其他扫描模式。基本扫描模式包含以下event：</p>
<p>1.将值加载到扫描链中。</p>
<p>2.强制所有非时钟主输入上的值（时钟关闭且受约束引脚处于其受约束值）。</p>
<p>3.测量所有主要输出（连接到扫描时钟的输出除外）。</p>
<p>4.脉冲捕获时钟或应用选定的时钟过程。</p>
<p>5.从扫描链卸载值。</p>
<p>虽然列表将扫描链的加载和卸载显示为单独的事件，但模式的加载与前一模式的卸载同时发生。因此，当在测试上应用模式时，只需要一个操作，即加载新模式的扫描值，同时将捕获的值卸载到前一模式的扫描链中。</p>
<p>Clock PO Patterns</p>
<p>下图显示了在某些设计中，时钟信号可能通过一些组合逻辑到达主输出。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/butcs-icwork-bentch/blogimg@main/img20250605143441452.png"></p>
<p>该工具考虑任何测量与时钟连接的PO的模式，无论时钟是否处于活动状态，都是时钟PO模式。正常扫描模式在force主输入和主输出的测量期间使所有时钟关闭。然而，在时钟控制的主输出情况下，如果时钟关闭，则可能不满足测试该电路中的故障所需的条件，并且故障可能未被检测到。在这种情况下，为了检测故障，模式必须在force和测量期间打开时钟。这在基本扫描模式中不会发生。该工具允许在时钟PO模式内进行此操作，以观察连接到时钟的主要输出。</p>
<p>Clock PO Patterns包含以下事件：</p>
<p>1.将值加载到扫描链中。</p>
<p>2.强制所有主要输入上的值，（可能）包括时钟（受约束的引脚处于其受约束的值）。</p>
<p>3.测量连接到扫描时钟的所有主要输出。</p>
<p>当该工具得知时钟连接到主输出，并且确定只能通过使用时钟PO模式检测与电路相关的故障时，该工具就会生成时钟PO模式。如果您不希望该工具生成时钟PO模式，可以按如下方式关闭该功能：</p>
<p>SETUP&gt; set_pattern_type -clock_po off</p>
<p>Clock Sequential Patterns</p>
<p>ATPG工具的时钟顺序模式类型处理有限的顺序电路，也有助于用RAM测试设计。这种模式包含以下事件：</p>
<p>1.加载扫描链。</p>
<p>2.应用时钟顺序循环。</p>
<p>a、 强制所有主要输入上的值，时钟除外（受约束管脚处于其受约束值）。</p>
<p>b、 脉冲写入线、读取线、捕获时钟和&#x2F;或应用选定的时钟过程。</p>
<p>c、 重复步骤a和b总共”N”次，其中N是时钟顺序深度-1。</p>
<p>3.应用捕获周期。</p>
<p>a、 force pi。</p>
<p>b、 measure po。</p>
<p>c、 脉冲捕获时钟。</p>
<p>4.加载下一个pattern时卸载扫描链。</p>
<p>要指示工具生成时钟顺序模式，必须使用set_pattern_type命令将顺序深度设置为大于1的某个数字，如下所示：SETUP&gt; set_pattern_type -sequential 2(比如2）</p>
<p>深度为零表示组合电路。深度大于1表示limited顺序电路。但是，应该注意指定的深度。您应该首先使用最低的顺序深度并分析运行结果。如有必要，您可以执行多次运行，每次增加顺序深度。尽管最大允许深度限制为255，但出于性能原因，通常应将指定的值限制为5或更少。</p>
<p>Multiple Load Patterns</p>
<p>该工具可以可选地以时钟顺序模式选择多个扫描链加载。使用多个load创建pattern，该工具能够执行以下操作：</p>
<p>•利用设计的非扫描顺序单元，该单元能够通过扫描加载操作保持其状态</p>
<p>•通过RAM&#x2F;ROM进行测试</p>
<p>可以通过在set_pattern_type命令中使用”-multiple_load on”并将顺序深度设置为大于1的数字来启用多重加载功能。当激活此功能时，允许工具在任何模式循环之前包括扫描加载。通常，multiple load patterns 需要每个功能模式时钟脉冲的顺序深度。要求最小顺序深度为4，以使工具能够创建RAM测试所需的多循环模式。这些模式与RAM顺序模式非常相似，但对于许多设计来说，将比RAM顺序模式提供更好的覆盖率。该方法还支持某些工具功能（宏测试、动态压缩、拆分捕获周期、时钟关闭模拟）。</p>
<p>RAM Sequential Patterns</p>
<p>为了通过RAM传播故障影响，并彻底测试与RAM相关的电路，该工具生成一种特殊类型的模式，称为RAM顺序模式。RAM顺序模式是具有多个负载的单个模式，它对测试RAM操作所必需的一些顺序事件进行建模。多个加载事件包括两次地址写入和可能的一次读取（如果RAM有数据保持）。此类型的模式包含以下事件：</p>
<ol>
<li><p>Load scan cells. </p>
</li>
<li><p>Force primary inputs. </p>
</li>
<li><p>Pulse write line(s). </p>
</li>
<li><p>Repeat steps 1 through 3 for a different address. </p>
</li>
<li><p>Load scan cells. </p>
</li>
<li><p>Force primary inputs. </p>
</li>
<li><p>Pulse read lines (optional, depending on the RAM’s data hold attribute). </p>
</li>
<li><p>Load scan cells. </p>
</li>
<li><p>Force primary inputs </p>
</li>
<li><p>Measure primary outputs. </p>
</li>
<li><p>Pulse capture clock. </p>
</li>
<li><p>Unload values from scan cells.</p>
</li>
</ol>
<p>下面的示例解释了这种模式中描述的操作。假设您想在地址线的最高位测试一个st-at-1故障。可以通过将一些数据D写入位置1000来实现这一点。然后，可以将不同的数据D’写入位置0000。如果在最高地址位上出现st-at-1故障，故障机器将用值D’覆盖位置1000。接下来，您将尝试从地址位置1000读取。如果地址线上出现st-at-1故障，您将读取D’。相反，如果地址线最高位的故障是一个st-at-0故障，则需要将初始数据D写入位置0000。然后将不同的数据D’写入位置1000。如果最高地址位出现st-at-0错误，则故障机器将用值D’覆盖位置0000。接下来，将尝试从地址位置0000读取。在地址线上出现st-at-0故障时，您将读取D’。可以通过发出set_pattern_type命令，指示该工具生成RAM顺序模式，如下所示：</p>
<p>SETUP&gt; set_pattern_type -ram_sequential on</p>
<p>Sequential Transparent Patterns</p>
<ol>
<li><p>Load scan chains. </p>
</li>
<li><p>Force primary inputs. </p>
</li>
<li><p>Apply  seq_transparent  procedure(s). </p>
</li>
<li><p>Measure primary outputs. </p>
</li>
<li><p>Unload scan chains.</p>
</li>
</ol>
<p>Tool Invocation</p>
<p>调用请使用”patterns -scan.”</p>
<p>%  tessent -shell</p>
<p>SETUP&gt; set_context patterns -scan</p>
<p>当Tessent Shell调用时，该工具假定您要做的第一件事是设置电路行为，因此它会自动将您置于设置模式。要将系统模式更改为分析，请使用set_system_mode命令。</p>
<p>Equivalent or Inverted Primary Input Definition</p>
<p>在电路应用环境中，通常被测试电路的多个主要输入必须始终具有相同（等效）或相反的值。指定管脚等效性将选定的主输入管脚约束为相对于上次输入的主输入pin的等效值或反向值。 </p>
<p>The following commands are useful when working with pin equivalences: </p>
<p>•  add_input_constraints  — Adds pin equivalences. </p>
<p>•  delete_input_constraints  — Deletes the specified pin equivalences. </p>
<p>•  report_input_constraints  — Displays the specified pin equivalences.</p>
<p>Primary Inputs and Outputs Addition</p>
<p>在某些情况下您可能需要更改测试模式应用点（主要输入）或输出值测量点（主要输出）。当您添加以前未定义的主输入时，它们称为用户类主输入，而原始的主输入称为系统类主输入。</p>
<p>要将add_primary_input到回路，请在设置模式提示符下，使用add_primary _input命令。您添加以前未定义的主输出时，它们称为用户类主输出，而原始主输出称为系统类主输出。要将add_primary_output添加到回路，请在设置模式提示符下，使用add_primary _output命令</p>
<p>You use the following command to report and delete primary inputs and outputs: </p>
<p>•  delete_primary_inputs  — Deletes the specified types of primary inputs. </p>
<p>•  report_primary_inputs  — Reports the specified types of primary inputs. </p>
<p>•  delete_primary_outputs  — Deletes the specified types of primary outputs. </p>
<p>•  report_primary_outputs  — Reports the specified types of primary outputs.</p>
<p>Bidirectional Pins as Primary Inputs or Outputs</p>
<p>在模式生成过程中，ATPG工具自动确定双向管脚（bidis）的模式，并避免在这些管脚不处于输入模式时创建驱动这些管脚上的值的模式。然而，在某些情况下，可能希望该工具将双向引脚视为PI或PO。例如，一些 testers 需要比PI或PO数据更多的内存来存储双向引脚数据。在生成和保存模式时，将每个bidi视为PI或PO将减少在这些 testers 上存储引脚数据所需的内存量。从该工具的角度来看，bidi由多个门组成，包括一个输入端口和一个输出端口。您可以使用report_primary_input和report_pprimary_output命令查看PI和PO。这两个命令列出的引脚是双向引脚。</p>
<p>某些其他特定于PI和特定于PO的命令接受bidi-piname参数，并允许您仅对bidi的适用端口功能（输入或输出）进行操作。对于例如，您可以使用带有双向pin参数的deleteprimaryinputs命令从设计界面中删除bidi的输入端口。从那时起，该工具将把该引脚视为PO。您可以类似地使用delete_primary_outputs命令从设计界面中删除bidi的输出端口，因此该工具将该bidi视为PI。</p>
<p>Bidirectional Pin as a Primary Output for ATPG Only</p>
<p>使用add_output_mask命令，可以使用该工具仅在ATPG期间将bidi视为PI，而无需更改设计界面。该命令阻止bidi的输出部分的可观察性。生成的模式将包含bidi的PI数据，您将能够通过使用原始设计网表执行模拟来验证保存的模式。 </p>
<p>If the Bidirectional Pin Control Logic is Unknown</p>
<p>有时bidi的控制逻辑是未知的。在这种情况下，可以将控制逻辑建模为黑盒。如果希望该工具将bidi视为PI，请将黑盒的输出建模为0。如果希望bidi被视为PO，请将黑盒的输出模型为1。</p>
<p>If the Bidirectional Pin has a Pull-up or Pull-down Resistor</p>
<p>使用默认设置，ATPG工具可以为上拉或下拉电阻器的双向pad生成已知值。然而，在现实中，上拉或下拉时间通常非常慢，并且在高速执行测试时将导致模拟失配。 为了防止这种不匹配，应该使用add_input_constraints命令。此命令更改工具对I&#x2F;Opad的模拟，以便为依赖于pad的所有观察点捕获X，而不是已知值。X遮蔽观察点，防止模拟不匹配。</p>
<p>Examples of Setup for Bidirectional Pins as PIs or POs</p>
<p>以下示例演示了前面关于双向引脚（bidis）的部分中描述的命令的使用。假设示例设计中存在以下引脚：</p>
<p>•  Bidirectional pins: &#x2F;my_inout[0]…&#x2F;my_inout[2] </p>
<p>•  Primary inputs (PIs): &#x2F;clk, &#x2F;rst, &#x2F;scan_in, &#x2F;scan_en, &#x2F;my_en </p>
<p>•  Primary outputs (POs): &#x2F;my_out[0]…&#x2F;my_out[4]</p>
<p>可以通过发出以下两个命令来查看bidis</p>
<p>SETUP&gt; report_primary_inputs </p>
<p>SYSTEM: &#x2F;clk </p>
<p>SYSTEM: &#x2F;rst </p>
<p>SYSTEM: &#x2F;scan_in </p>
<p>SYSTEM: &#x2F;scan_en </p>
<p>SYSTEM: &#x2F;my_en </p>
<p>SYSTEM: &#x2F;my_inout[2] </p>
<p>SYSTEM: &#x2F;my_inout[1] </p>
<p>SYSTEM: &#x2F;my_inout[0] </p>
<p>SETUP&gt; report_primary_outputs </p>
<p>SYSTEM: &#x2F;x_out[4] </p>
<p>SYSTEM: &#x2F;x_out[3] </p>
<p>SYSTEM: &#x2F;x_out[2] </p>
<p>SYSTEM: &#x2F;x_out[1] </p>
<p>SYSTEM: &#x2F;x_out[0] </p>
<p>SYSTEM: &#x2F;my_inout[2] </p>
<p>SYSTEM: &#x2F;my_inout[1] </p>
<p>SYSTEM: &#x2F;my_inout[0] </p>
<p>两个命令输出中列出的引脚（以粗体显示）是工具在测试生成期间将作为bidis处理的引脚。要强制工具将bidi视为PI或PO，可以删除不需要的输入或输出端口的定义定义，然后报告PI和PO。您可以看到该工具现在只将BIDI报告为PO，这反映了在ATPG期间如何处理这些引脚：</p>
<p>SETUP&gt; delete_primary_inputs &#x2F;my_inout[0] &#x2F;my_inout[1] &#x2F;my_inout[2] </p>
<p>SETUP&gt; report_primary_inputs </p>
<p>SYSTEM: &#x2F;clk </p>
<p>SYSTEM: &#x2F;rst </p>
<p>SYSTEM: &#x2F;scan_in </p>
<p>SYSTEM: &#x2F;scan_en </p>
<p>SYSTEM: &#x2F;my_en </p>
<p>SETUP&gt; report_primary_outputs </p>
<p>SYSTEM: &#x2F;x_out[4] </p>
<p>SYSTEM: &#x2F;x_out[3] </p>
<p>SYSTEM: &#x2F;x_out[2] </p>
<p>SYSTEM: &#x2F;x_out[1] </p>
<p>SYSTEM: &#x2F;x_out[0] </p>
<p>SYSTEM: &#x2F;my_inout[2] </p>
<p>SYSTEM: &#x2F;my_inout[1] </p>
<p>SYSTEM: &#x2F;my_inout[0] </p>
<p>因为删除不需要的主要输入和输出会改变工具中的设计界面，所以在所有情况下可能都是不可接受的。如前所述，另一种方法是让该工具仅在ATPG期间将bidi视为PI或PO，而不改变设计界面。为了获得bidi的PO处理，将bidi输入部分限制为高阻抗状态。以下命令对&#x2F;my_out[0]bidi执行此操作：</p>
<p>SETUP&gt; add_input_constraints &#x2F;my_inout[0] -cz </p>
<p>要使工具仅在ATPG期间将bidi视为PI，请指示工具屏蔽（忽略）bidi的输出部分。以下示例为&#x2F;my_out[0]和&#x2F;my_inout[1]管脚执行此操作：</p>
<p>SETUP&gt; add_output_masks &#x2F;my_inout[0] &#x2F;my_inout[2] </p>
<p>SETUP&gt; report_output_masks </p>
<p>TIEX &#x2F;my_inout[0] </p>
<p>TIEX &#x2F;my_inout[2] </p>
<p>“report_output_mask”输出中的”TIEX”表示两个引脚现在绑定到X，这会阻止它们的可观察性，并防止工具在ATPG期间使用它们</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://butcs-icwork-bentch.github.io">butc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://butcs-icwork-bentch.github.io/2025/06/04/DFT3_tessent_CSDN/">https://butcs-icwork-bentch.github.io/2025/06/04/DFT3_tessent_CSDN/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://butcs-icwork-bentch.github.io" target="_blank">Welcome to butcs-icworkbentch</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/tessent/">tessent</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/butcs-icwork-bentch/blogimg@main/imgOIP-C.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/06/04/DFT3/" title="DFT学习（3）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">DFT学习（3）</div></div><div class="info-2"><div class="info-item-1">LBIST在上一学习中，我们展示了不完备LBIST的建立方法，为什么说是不完备的呢？诸位可以看看代码组成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// 纯LBIST结构乘法器(无扫描链)module multiplier_4bit_lbist(    input clk,           // 时钟信号    input rst_n,         // 复位信号    input test_mode,     // 测试模式信号    input bist_en,       // BIST使能信号    input bist_start,   ...</div></div></div></a><a class="pagination-related" href="/2025/06/04/DFT4/" title="DFT学习（4）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">DFT学习（4）</div></div><div class="info-2"><div class="info-item-1">mbistmbist是主要针对于高可靠性soc芯片所设计的线上测试方法，通常用于车规，工业级，军用级等芯片上。目前soc芯片hard marco单元大约达到了数字芯片面积的80%，是面积最大的部分，其可靠性的测量是必要的，但是针对于纯逻辑控制单元，没有这样的mem结构，常用lbist和scan即可。其模型如下要对rom进行检测首先要知道rom的结构，rom其实就是一个一个的小模拟存储电路阵列拼起来的存储电路，其可以看作列地址n和行地址m控制的数字电路，将m和n都看作ii口，其实用之前的办法也可以进行检测，但是成本很高，速度很慢，我们现有的rom主要分为以下几种： ROM类型及特点   ROM类型 特点    掩模ROM（Mask...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/butcs-icwork-bentch/blogimg@main/imgOIP-C.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">butc</div><div class="author-info-description">一个分享技术、生活、学习、工作、创业等内容的博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/butcs-icwork-bentch"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https:2806483105@qq.com" target="_blank" title="QQ"><i class="fab fa-QQ" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%90%E5%89%8D%E5%A3%B0%E6%98%8E%EF%BC%9A%E6%9C%AC%E6%96%87%E6%98%AFcsdn%E9%93%BE%E6%8E%A5%E7%BD%91%E9%A1%B5%EF%BC%8C%E9%9D%9E%E6%9C%AC%E4%BA%BA%E5%88%9B%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text">提前声明：本文是csdn链接网页，非本人创建</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/DFT3/" title="DFT学习（3）">DFT学习（3）</a><time datetime="2025-06-04T04:45:00.000Z" title="发表于 2025-06-04 12:45:00">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/DFT3_tessent_CSDN/" title="DFT_tessent_csdn">DFT_tessent_csdn</a><time datetime="2025-06-04T04:45:00.000Z" title="发表于 2025-06-04 12:45:00">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/04/DFT4/" title="DFT学习（4）">DFT学习（4）</a><time datetime="2025-06-04T04:45:00.000Z" title="发表于 2025-06-04 12:45:00">2025-06-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/03/PCB%E7%BB%98%E5%88%B6/" title="PCB绘制">PCB绘制</a><time datetime="2025-06-03T05:20:00.000Z" title="发表于 2025-06-03 13:20:00">2025-06-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/05/28/DFT2%E5%AE%9E%E6%93%8D/" title="DFT学习（2）实操">DFT学习（2）实操</a><time datetime="2025-05-28T15:36:00.000Z" title="发表于 2025-05-28 23:36:00">2025-05-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/butcs-icwork-bentch/blogimg@main/imgshaqiu.png);"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By butc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@5.3.5/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@5.3.5/source/js/main.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>